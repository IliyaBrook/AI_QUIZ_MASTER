{
    "quiz": [
      {
        "question": "Какой хук следует использовать для выполнения побочных эффектов в функциональных компонентах, таких как получение данных или подписка на события?",
        "options": [
          {
            "text": "useState",
            "isCorrect": false,
            "rationale": "useState используется для управления состоянием в функциональных компонентах, а не для побочных эффектов."
          },
          {
            "text": "useEffect",
            "isCorrect": true,
            "rationale": "useEffect предназначен для управления побочными эффектами, синхронизируя их с жизненным циклом компонента."
          },
          {
            "text": "useContext",
            "isCorrect": false,
            "rationale": "useContext позволяет получать доступ к значению контекста, но не предназначен для побочных эффектов."
          },
          {
            "text": "useReducer",
            "isCorrect": false,
            "rationale": "useReducer — это альтернатива useState для более сложного управления состоянием, но не для побочных эффектов."
          }
        ],
        "hint": "Подумайте, какой хук React предоставляет механизм для 'слушания' изменений и выполнения действий в ответ на них."
      },
      {
        "question": "Вы хотите оптимизировать производительность компонента, предотвращая его повторный рендеринг, если пропсы не изменились. Какой хук или технику вы примените?",
        "options": [
          {
            "text": "useCallback",
            "isCorrect": false,
            "rationale": "useCallback мемоизирует функции, но не предотвращает рендеринг компонента в целом, если пропсы изменились."
          },
          {
            "text": "useMemo",
            "isCorrect": false,
            "rationale": "useMemo мемоизирует значения, а не сам компонент или его рендеринг."
          },
          {
            "text": "React.memo",
            "isCorrect": true,
            "rationale": "React.memo — это HOC (Higher-Order Component), который мемоизирует функциональный компонент, предотвращая его повторный рендеринг, если пропсы не изменились."
          },
          {
            "text": "useRef",
            "isCorrect": false,
            "rationale": "useRef используется для создания изменяемых ссылок, но не для оптимизации рендеринга компонента."
          }
        ],
        "hint": "Рассмотрите возможность мемоизации не значения или функции, а самого компонента."
      },
      {
        "question": "При работе с пользовательским хуком, который содержит логику для подписки и отписки от события, в каком хуке следует выполнять очистку (отписку)?",
        "options": [
          {
            "text": "Внутри функции, переданной в useCallback",
            "isCorrect": false,
            "rationale": "useCallback мемоизирует колбэки, но не предназначен для управления жизненным циклом подписок."
          },
          {
            "text": "Внутри функции, возвращаемой из useEffect",
            "isCorrect": true,
            "rationale": "Функция, возвращаемая из useEffect, выполняется при размонтировании компонента или перед каждым повторным выполнением эффекта, что идеально подходит для очистки."
          },
          {
            "text": "Внутри функции, переданной в useMemo",
            "isCorrect": false,
            "rationale": "useMemo мемоизирует значения и не предназначен для выполнения побочных эффектов или очистки."
          },
          {
            "text": "Непосредственно в теле функционального компонента",
            "isCorrect": false,
            "rationale": "Выполнение очистки напрямую в теле компонента может привести к утечкам памяти и неконтролируемым побочным эффектам."
          }
        ],
        "hint": "Подумайте о механизме 'очистки' в хуке, который используется для побочных эффектов. Он похож на componentWillUnmount или возврат из componentDidUpdate."
      },
      {
        "question": "У вас есть большое состояние в компоненте, и вы обнаружили, что логика обновления этого состояния становится слишком сложной. Какой хук будет наиболее подходящим для рефакторинга этой логики?",
        "options": [
          {
            "text": "useState",
            "isCorrect": false,
            "rationale": "useState подходит для простого состояния, но для сложной логики обновления может стать громоздким."
          },
          {
            "text": "useContext",
            "isCorrect": false,
            "rationale": "useContext используется для передачи данных по дереву компонентов, а не для управления сложной логикой состояния."
          },
          {
            "text": "useReducer",
            "isCorrect": true,
            "rationale": "useReducer позволяет централизовать логику обновления состояния в редьюсере, что делает ее более предсказуемой и тестируемой, особенно для сложного состояния."
          },
          {
            "text": "useEffect",
            "isCorrect": false,
            "rationale": "useEffect предназначен для побочных эффектов, а не для управления основной логикой обновления состояния."
          }
        ],
        "hint": "Подумайте о шаблоне, который используется в Redux для управления состоянием. Есть аналог в React Hooks."
      },
      {
        "question": "Как можно передать данные глубоко вложенным компонентам без использования пропсов через каждый промежуточный компонент?",
        "options": [
          {
            "text": "Использовать пропсы и явно передавать их вниз по дереву.",
            "isCorrect": false,
            "rationale": "Это подход известен как 'prop drilling' и является неэффективным для глубокой вложенности."
          },
          {
            "text": "Использовать Redux для глобального состояния.",
            "isCorrect": false,
            "rationale": "Redux — это внешняя библиотека для управления состоянием, а не встроенный хук React для этой цели."
          },
          {
            "text": "Использовать хук useContext и Context API.",
            "isCorrect": true,
            "rationale": "useContext в сочетании с Context API позволяет передавать данные 'вниз' по дереву компонентов без необходимости явной передачи пропсов на каждом уровне."
          },
          {
            "text": "Использовать useRef для доступа к состоянию родителя.",
            "isCorrect": false,
            "rationale": "useRef не предназначен для доступа к состоянию родителя и его изменения, а для создания изменяемых ссылок на DOM-элементы или значения."
          }
        ],
        "hint": "В React есть встроенный механизм для создания 'глобального' хранилища данных, к которому могут получить доступ любые дочерние компоненты."
      },
      {
        "question": "Вы хотите создать пользовательский хук `useFetchData` для получения данных с API. Где следует разместить логику асинхронного запроса и обработки состояния загрузки/ошибки?",
        "options": [
          {
            "text": "Внутри функции, возвращаемой из `useCallback`.",
            "isCorrect": false,
            "rationale": "useCallback мемоизирует функции, но не предназначен для выполнения асинхронных операций и управления их состоянием."
          },
          {
            "text": "Внутри функции `useEffect`.",
            "isCorrect": true,
            "rationale": "Асинхронные запросы данных являются побочными эффектами, и `useEffect` является подходящим местом для их выполнения и управления соответствующим состоянием (загрузка, данные, ошибка)."
          },
          {
            "text": "Напрямую в теле пользовательского хука `useFetchData`.",
            "isCorrect": false,
            "rationale": "Выполнение асинхронных запросов напрямую в теле хука приведет к их повторному выполнению при каждом рендеринге."
          },
          {
            "text": "Внутри функции, переданной в `useMemo`.",
            "isCorrect": false,
            "rationale": "useMemo мемоизирует значения и не предназначен для выполнения асинхронных операций."
          }
        ],
        "hint": "Вспомните, какой хук предназначен для работы с побочными эффектами и когда эти эффекты должны срабатывать или очищаться."
      },
      {
        "question": "При использовании `useCallback` для мемоизации функции, какие зависимости следует указывать в массиве зависимостей, чтобы функция не 'старела'?",
        "options": [
          {
            "text": "Только переменные, объявленные внутри этой же функции.",
            "isCorrect": false,
            "rationale": "Необходимо указывать все переменные, функции и состояния, которые используются внутри мемоизированной функции и могут изменяться между рендерами."
          },
          {
            "text": "Все пропсы и состояния, которые используются внутри мемоизированной функции.",
            "isCorrect": true,
            "rationale": "Для корректной работы `useCallback` необходимо включать в массив зависимостей все переменные, функции и состояния из замыкания, которые используются внутри мемоизированной функции. Это гарантирует, что функция будет обновлена только при изменении этих зависимостей."
          },
          {
            "text": "Пустой массив `[]`, чтобы функция создавалась только один раз.",
            "isCorrect": false,
            "rationale": "Пустой массив приведет к тому, что функция будет использовать замыкание, которое было при первом рендере, что может вызвать проблемы со 'старым' состоянием или пропсами."
          },
          {
            "text": "Зависимости указывать не обязательно, `useCallback` сам отслеживает изменения.",
            "isCorrect": false,
            "rationale": "`useCallback` требует явного указания зависимостей для корректной работы мемоизации."
          }
        ],
        "hint": "Подумайте о том, когда мемоизированная функция должна быть пересоздана. Это должно произойти, когда ее 'окружение' меняется."
      },
      {
        "question": "Какой хук можно использовать для доступа к DOM-элементу или для хранения изменяемого значения, которое не вызывает повторный рендеринг при его изменении?",
        "options": [
          {
            "text": "useState",
            "isCorrect": false,
            "rationale": "useState вызывает повторный рендеринг при изменении состояния, что не соответствует требованиям."
          },
          {
            "text": "useEffect",
            "isCorrect": false,
            "rationale": "useEffect используется для побочных эффектов, а не для хранения изменяемых ссылок."
          },
          {
            "text": "useRef",
            "isCorrect": true,
            "rationale": "useRef позволяет создавать изменяемые ссылки на DOM-элементы или хранить произвольные значения, которые не вызывают повторный рендеринг при их изменении."
          },
          {
            "text": "useLayoutEffect",
            "isCorrect": false,
            "rationale": "useLayoutEffect похож на useEffect, но синхронно срабатывает после всех изменений DOM, не для хранения изменяемых ссылок."
          }
        ],
        "hint": "Представьте себе 'коробку', в которую вы можете положить что-то, и это 'что-то' будет оставаться там между рендерами, не вызывая их."
      },
      {
        "question": "Вы разрабатываете компонент, который должен выполнять определенные действия (например, прокрутку к элементу) сразу после того, как браузер обновил DOM. Какой хук следует использовать для этого?",
        "options": [
          {
            "text": "useEffect",
            "isCorrect": false,
            "rationale": "useEffect выполняется асинхронно после рендеринга и возможной отрисовки браузером, что может привести к 'морганию' при манипуляциях с DOM."
          },
          {
            "text": "useLayoutEffect",
            "isCorrect": true,
            "rationale": "useLayoutEffect синхронно срабатывает сразу после всех изменений DOM, но до того, как браузер обновит экран. Это делает его идеальным для манипуляций с DOM, которые должны быть видимы немедленно."
          },
          {
            "text": "useImperativeHandle",
            "isCorrect": false,
            "rationale": "useImperativeHandle используется для настройки значений, которые могут быть доступны родительским компонентам через ref, а не для выполнения действий после обновления DOM."
          },
          {
            "text": "useCallback",
            "isCorrect": false,
            "rationale": "useCallback мемоизирует функции и не предназначен для выполнения действий после обновления DOM."
          }
        ],
        "hint": "Подумайте о порядке выполнения хуков в жизненном цикле рендеринга и о том, когда изменения в DOM становятся видимыми пользователю."
      },
      {
        "question": "При использовании `useReducer` для управления состоянием, как получить доступ к последнему состоянию из функции-редьюсера?",
        "options": [
          {
            "text": "Через замыкание, так как редьюсер всегда имеет доступ к актуальному состоянию.",
            "isCorrect": false,
            "rationale": "Редьюсер получает текущее состояние как первый аргумент, а не через замыкание."
          },
          {
            "text": "Состояние передается как первый аргумент в функцию редьюсера.",
            "isCorrect": true,
            "rationale": "Функция редьюсера `(state, action) => newState` всегда получает текущее состояние как первый аргумент, что позволяет ей вычислять новое состояние на основе предыдущего."
          },
          {
            "text": "Использовать `useRef` для хранения состояния и получения его в редьюсере.",
            "isCorrect": false,
            "rationale": "Хранение состояния в `useRef` и доступ к нему в редьюсере нарушит принцип `useReducer` и сделает управление состоянием непредсказуемым."
          },
          {
            "text": "Состояние доступно как свойство объекта `action`.",
            "isCorrect": false,
            "rationale": "Объект `action` содержит информацию о типе действия и опциональные данные (`payload`), но не само текущее состояние."
          }
        ],
        "hint": "Вспомните сигнатуру функции-редьюсера. Как в нее передаются данные?"
      }
    ]
  }